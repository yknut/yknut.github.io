[{"title":"C语言程序设计基础09-结构与共用体","date":"2021-12-19T15:42:39.000Z","url":"/2021/12/19/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%8009-%E7%BB%93%E6%9E%84%E4%B8%8E%E5%85%B1%E7%94%A8%E4%BD%93/","tags":[["C编程","/tags/C%E7%BC%96%E7%A8%8B/"],["C/C++","/tags/C-C/"]],"categories":[["C/C++编程","/categories/C-C-%E7%BC%96%E7%A8%8B/"]],"content":"结构类型与结构体变量结构类型的定义： 结构是逻辑上相互联系的一组分量的集合。 结构中的分量可以是不同类型的数据，称为结构的成员。 在使用结构之前，首先根据具体问题，利用已有的数据类型对结构的组成进行描述，称为结构的定义(声明)。 一般形式： 注意：&lt;color 大括号后面的分号;不能少。 结构变量的定义： 在定义结构类型之后，表示声明了一种新的数据类型,并没有内存空间的分配。 必须用结构类型定义相应的变量才能使用。 三种形式： 先声明结构类型再定义变量 在声明结构类型的同时定义变量 省去结构标签直接定义变量 可用typedef定义一个新的数据类型名 例如： 这样可以直接使用STU定义变量，如 结构变量的存储: 结构变量的存储分配与计算机系统及所定义的结构有关。为了提高CPU的存储速度，多数编译系统对结构中的成员变量的存储分配采用按字节“对齐”的方法。分配原则如下： 各成员按照定义顺序依次存放，但并不是紧密排列，成员的存储位置存储在自己宽度的整数倍上开始。 检查所有成员的存储单元长度之和是否为成员中最宽的元素长度的整数倍，若不是，则补齐为整数倍。 结构变量的初始化： 一般形式： 结构变量的引用： 一般形式： 结构变量的使用规则： 对于整个结构，可以做赋值、取地址，也可以传递给函数参数。 例如： 不能将一个结构变量作为一个整体进行输入和输出;只能对其各个成员分别进行操作。 若成员本身又属于一个结构体类型，只能对最低级的成员进行存取以及运算。 对成员变量可以象普通变量一样进行各种运算。 可以引用成员的地址，也可以引用结构体变量的地址。 与数组不同，结构变量的名字不是其地址，如果想获得其地址，需要使用&amp;运算符。 注意：结构变量的名字并不是结构变量的地址，必须用&amp;运算符。 结构数组结构数组的定义： 结构体数组是一个数组,其数组的每一个元素都是结构体类型。 一般形式： 结构体数组的使用和结构体变量是一样的。 结构体数组的初始化和引用： 例如： 总结： 结构数组的定义与结构变量的定义类似。 与数组一样，结构数组的初始化也可以在定义时进行。 一维结构数组的初始化格式与二维数组类似。 结构指针指向结构变量的指针当一个指针用来指向一个结构体变量时,称之为结构体指针变量。结构体指针变量中的值是所指向的结构变量的首地址，通过结构指针即可访问该结构变量。 一般形式： 例如： 获取结构体成员 一般形式： 或者 指向结构数组的指针例如： 获取结构体成员 指针访问 总结： 指向结构的指针称为结构变量的指针。 结构变量的指针是该结构变量所占的内存段的起始地址。 结构指针的运算同普通变量。 结构体作为函数参数结构变量作参数 整个结构作为函数的参数 将结构作为整体，在函数之间传递整个结构; 在被函数内新建一个结构变量，并接受调用者的值。 结构成员作为函数的参数 在函数之间传递成员的值; 与传递简单变量的方法相同 函数也可以返回一个结构 结构指针作参数 向函数传递的是结构的首地址 形参可以是结构数组，传递的是结构指针的值 传入传出的只是一个指针的大小，而不是整个结构 函数也可以返回一个结构指针 结构数组作参数 向函数传递的是结构数组的首地址 形参可以是结构数组，也可以是结构指针 仅复制结构的首地址，这种按地址传递方式效率更高 共用体在 C 语言中, 允许几种不同类型的变量存放到同一段内存单元中, 也就是使用覆盖技术, 几个变量互相覆盖。这种几个不同的变量共同占用一段内存的结构, 被称为共用体类型结构, 简称共用体。 一般形式： 共用体与结构的异同点： 相似点 共用体的类型声明、变量定义及引用方式与结构相似。 不同点 结构变量所占内存长度, 根据编译系统环境有所不同, 采用字节对齐的方法。 共用体变量所占内存长度等于最长的成员的长度。 共用体变量的定义： 共用体变量的存储： 所有的成员共享一个空间 同一时间只有一个成员是有效的 用sizeof (union data)得到的占内存最长的成员的长度 共用体变量的初始化和引用： 只能初始化第一个成员 共用体变量的引用方式与结构变量相同 但，同一时间只有一个成员是有效的。 共用体变量的可以整体引用 共用体变量可以作为函数的参数，函数也可以返回共用体变量 共用体变量的地址和它的各成员的地址都是同一地址。 枚举类型当一个变量的取值只限定为几种可能时，如星期几，就可以使用枚举类型。枚举是将可能的取值一一列举出来，那么变量的取值范围也就在列举值的范围之内。 一般形式： 枚举类型 枚举类型说明中的枚举值本身就是常量，不允许对其进行赋值操作。 第一个枚举值序号为0，因此它的值为0，以后依次加1。也可人为指定序号值。 枚举值可以进行比较。 "},{"title":"C语言程序设计基础08-指针","date":"2021-12-12T12:30:15.000Z","url":"/2021/12/12/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%8008-%E6%8C%87%E9%92%88/","tags":[["C编程","/tags/C%E7%BC%96%E7%A8%8B/"],["C/C++","/tags/C-C/"]],"categories":[["C/C++编程","/categories/C-C-%E7%BC%96%E7%A8%8B/"]],"content":"所谓指针，也就是内存的地址；所谓指针变量，也就是保存了内存地址的变量。 指针的定义和使用指针的定义内存和地址： 内存：就是内部存储器，是由存储单元组成的，它是线性连续的。存储单元的最小单位是字节。 内存地址按字节编号，其字长一般与主机相同。32位机使用32位地址，最多支持2^32字节内存(4G)。 CPU 只能通过地址来取得内存中的代码和数据，程序在执行过程中会告知 CPU 要执行的代码以及要读写的数据的地址 变量地址：系统分配给变量的内存单元的起始地址 变量的寻址方式： 直接寻址：通过变量名访问变量 间接寻址：通过指针访问变量 指针：一个变量的地址。 指针变量：用于存放变量的地址（指针）的变量。 利用指针变量实现了对变量的间接访问。 一般形式： 指针的使用 取地址运算 一般形式 例如 取内容运算 一般形式 若*p出现在赋值号左边，表示给p所指变量赋值； 若*p不出现在赋值号左边，表示p所指变量的值 例如 为指针变量赋初值 定义指针变量并初始化 使用赋值语句赋值 为指针赋空值(NULL) 此时指针不指向任何变量，NULL是在stdio.h中定义的符号常数 #define NULL 0 指针的运算指针的算术运算指针表达式和常量的加减运算 一般形式： 计算规则 表达式p+n 的值=p的值 + p所指类型长度*n 表达式p-n 的值=p的值 - p所指类型长度*n 说明： 只有当p和p+n或p-n都指向连续存放的同类型数据区域（数组）时，指针加、减才有实际意义。 指针自增自减运算 形式： 前缀：++p; --p; 后缀：p++; p--; 功能： 进行++p或p++运算后都使p指向下一个数据； 表达式p++的值等于p的原来值； 表达式++p的值等于p的新值； 说明： 取内容运算符”*”、取地址运算符”&amp;”和自增自减运算符都是单目运算符，运算的优先级相同，结合方向都是自右至左。 关于 *和 &amp;的运算： 指针的关系运算当两个指针指向同一个数组中的元素时，才能进行&gt;、&lt;、&gt;=、&lt;=、!=、==的关系运算。 任何指针p与NULL进行&quot;p==NULL&quot;或&quot;p!=NULL&quot;运算均有意义：判断指针p是否指向空。 指针的关系运算只有同类指针进行比较才有意义。 语法：指针表达式 关系运算符 指针表达式 ==和!=运算符，比较两个指针表达式是否指向同一个内存单元; &lt;、&lt;=、&gt;、&gt;=，比较两个指针所指内存区域的先后次序。 同类指针相减语法：p-q 说明： 同类指针相减时，两个指针应该指向连续存放的同类数据区域。 p-q的值，等于(p的值-q的值)/所指类型长度, 即p, q两个指针之间数据元素的个数。 强制类型转换运算格式：(类型名*)指针表达式 功能：将指针表达式的值转换成指定类型的指针。 指针和数组数组中的每个元素都可以通过下标唯一确定，即通过下标可以访问(操作)数组中的元素。 在C语言中，凡是可以通过数组下标方式完成的访问(操作)均可以通过指针方式实现。 数组名就是数组的首地址常量，就是第 0 号元素的地址。 例如： 访问数组： 下标方式 用 a[i] 形式访问数组元素 指针访问 通过指向数组元素的指针变量访问所需元素。 p指向a数组的第1个元素a[0]，则*p等于a[0] p+i指向a数组的第i个元素a[i]，则*(p+i)等于a[i] 例如： 使用指针遍历数组 关于数组指针： 数组与指针的本质区别： 数组名是指针常量，不能改变指针常量的值，a++;a+=2;a=p;都是非法的。 指针p是变量，若p指向数组的首地址，p+1代表该类型的下一变量的地址。 指针和字符串除了之前指针的初始化方法，还可以用字符串常量对字符指针进行初始化 此时,字符指针指向一个字符串常量的首地址。 字符串中每个字符的类型都是char，所以 字符指针的类型也必须是char *。 字符指针和字符数组的区别： 在内存中，字符数组存储在全局数据区或栈区，指针实现的字符串存储在常量区。全局数据区和栈区的字符串（也包括其他数据）有读取和写入的权限，而常量区的字符串（也包括其他数据）只有读取权限，没有写入权限。 字符数组由若干个元素组成，每个元素中放一个字符，而字符指针变量中存放的是字符串的首地址。 字符指针的赋值方式有三种： 字符指针 str 是个变量,可以改变 str 使它指向不同的字符串, 但不能改变 str 所指向的字符串常量的值。 如果需要修改字符串的内容需要借助字符数组 指针和函数指针变量作函数参数函数的参数不仅可以是整型、实型、字符型，还可以是指针型 它的作用是将一个变量的地址传送到另外一个函数中。 示例： 交换两个变量的值 输出结果：x = 10, y = 20 在swap函数中，x和y的值是互换了，但main函数中，a, b的值并未互换。 输出结果：x = 10, y = 20 通过改变指针形参的值，也不能改变指针实参的值。 输出结果：x = 20, y = 10 被调用函数不能改变实参指针变量的值，但可以改变实参指针变量所指向的变量的值。 数组名作函数参数当用数组名作为参数时，如果形参数组中元素的值发生变化，实参数组元素的值也随之变化。 若有一个实参数组，想在函数中改变此数组的元素的值，有四种情况： 形参与实参都用数组名 实参用数组名，形参用指针变量 实参形参均用指针变量 实参为指针变量，形参为数组名 都是地址传递，只是形式不同。 注意： 指针变量在作实参时，必须有确定的值，即指向一个已定义的单元。 返回指针的函数定义形式： 该函数的返回值是一个指针，其他和一般函数相同 指针数组指针数组：数组中的元素均为指针类型。 定义形式： [] 比*优先级高，因此pa先与[10]结合，形成pa[10]，具有10个元素。然后再与*结合，表示此数组中每一个元素是指针型的。 功能： 定义一个由10个指针变量构成的指针数组，数组中的每个数组元素都是一个指向一个整数的指针变量。 初始化： 必须使用地址值为指针数组初始化 指针和字符串数组字符串数组：数组中的每个元素都是存放字符的数组；字符串数组的每一行可存放一个字符串。 给字符串数组赋初值： 直接给字符串数组赋初值 由于字符串长短不一，定义时应考虑最长的串和结束标志的位置。防止造成内存单元浪费。 用指针数组处理多个字符串 此时，数组中的每个元素都存放着对应的一个字符串的首地址。各字符串依次存入各相应的首地址开始的连续存储单元中。 使用指针数组可以大大节省内存空间。 注意： 二级指针如果一个指针指向的是另外一个指针，我们就称它为二级指针，或者指向指针的指针。 例如： 指针变量也是一种变量，也会占用存储空间，也可以使用&amp;获取它的地址。 C语言不限制指针的级数，每增加一级指针，在定义指针变量时就得增加一个星号*。 指向数组的指针变量一般形式：类型说明符 (*变量名)[正整型常量表达式]; 定义一个名为“变量名”的指针变量，这个指针变量所指的对象是一个有“正整型常量表达式”个元素的一维数组(建立一个与二维数组名一样的行指针) 例如： 需要使用二维数组给指针赋初值。 第i行j列元素的地址为：*(p+i)+j 第i行j列元素的值为：*(*(p+i)+j) 指向函数的指针变量一个函数总是占用一段连续的内存区域，函数名在表达式中有时也会被转换为该函数所在内存区域的首地址，这和数组名非常类似。我们可以把函数的这个首地址（或称入口地址）赋予一个指针变量，使指针变量指向函数所在的内存区域，然后通过指针变量就可以找到并调用该函数。这种指针就是函数指针。 定义形式： ()的优先级高于*，所以(*函数名)的括号不能省略，否则就变成返回值为指针的函数"},{"title":"C语言程序设计基础07-变量的作用域和编译预处理","date":"2021-12-11T01:52:59.000Z","url":"/2021/12/11/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%8007-%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E7%BC%96%E8%AF%91%E9%A2%84%E5%A4%84%E7%90%86/","tags":[["C编程","/tags/C%E7%BC%96%E7%A8%8B/"],["C/C++","/tags/C-C/"]],"categories":[["C/C++编程","/categories/C-C-%E7%BC%96%E7%A8%8B/"]],"content":"变量的作用域是指变量在程序中的作用范围；变量的生存期是指变量值存在时间的长短。 作用域划分的变量局部变量定义在函数内部的变量称为局部变量（Local Variable），它的作用域仅限于函数内部， 离开该函数后就是无效的，再使用就会报错。 局部变量的规则 局部变量不会默认初始化 编译系统不为局部变量分配内存单元，只是当被调用时，分配临时单元，调用结束后，变量就消失了; 不同函数中可以定义同名变量，它们占据不同的内存单元; 在复合语句中定义的变量，只在本复合语句中有效; 在同一个块内（函数或复合语句内）不能定义相同的变量; main函数中定义的变量也是局部变量，只在main函数中有效。main函数也不能使用其他函数定义的变量。 全局变量在所有函数外部定义的变量称为全局变量（Global Variable），它的作用域默认是整个程序，也就是所有的源文件，包括 .c 和 .h 文件。 全局变量的规则 若全局变量与局部变量同名，则在局部变量的作用范围内，同名的全局变量不起作用； 没赋初值的全局变量默认得到0值； 任何函数都可以使用全局变量。 全局变量的优缺点优点： 函数间数据联系:同一文件中的一些函数引用全局变量，当某个函数中改变了全局变量的值，其它函数中的全局变量值也随之改变。 函数可以得到多个返回值。利用全局变量的这个特性，可以在函数间传递数据。 缺点： 全局变量在程序的全部执行过程中都占用存储单元。 降低函数的通用性。 变量的存储类型从变量值存在的时间（即生存期）看，变量的存储有两种不同的方式:静态存储和动态存储。 静态存储方式：在程序运行期间由系统分配固定的存储空间；从程序开始执行到程序结束。变量的值在整个程序中始终存在。 动态存储方式：在程序运行期间根据需要进行动态的分配存储空间；从包含该变量定义的函数开始执行至函数执行结束。变量的值只在函数调用期存在。 变量在内存中的存放位置和类型存储空间划分： 程序区 静态存储区：全局变量，局部静态变量 动态存储区：形参、局部变量、函数调用的现场等 存储类型： auto 自动变量——动态存储区 register 寄存器变量——CPU中的寄存器 extern 外部变量——静态存储区 外部变量(即全局变量)是在函数的外部定义的，它的作用域为从变量定义处开始，到本程序文件的末尾。如果外部变量不在文件的开头定义，其有效的作用范围只限于定义处到文件末尾。如果在定义点之前的函数想引用该外部变量，则应该在引用之前用关键字 extern 对该变量进行“外部变量声明”。表示该变量是一个已经定义的外部变量。 static 静态变量——静态存储区 局部变量的存储方式 自动变量(auto) 函数中的局部变量，如不专门声明为 static 存储类别，都是动态地分配存储空间的，数据存储在动态存储区中。函数中的形参和在函数中定义的变量(包括在复合语句中定义的变量)都属此类，在调用该函数时系统会给它们分配存储空间，在函数调用结束时就自动释放这些存储空间。自动变量用关键字 auto 进行存储类别的声明。 定义形式： 说明： 自动变量必须在一个函数体的内部，分配在动态存储区。 自动变量不赋初值，其值不确定。每调用一次，重新赋值一次。 函数的形参也是自动变量。 “自动”体现在进入语句块时自动申请内存，退出时自动释放内存;对它们分配和释放存储空间的工作由编译系统自动处理。 静态局部变量(static) 有时希望函数中局部变量的值在函数调用结束后不消失（以后一直存在，并总是保持它的最新值，即具有记忆性），即不释放存储单元。此时可指定该变量为“静态局部变量”。 定义形式： 特性： 静态局部变量系统自动初始化为0，存放在静态存储区；生存期为整个程序运行期间； 静态局部变量和全局变量都是静态存储类型，但作用域不同； 静态局部变量在编译时赋初值，每次调用时不再赋初值，只保留调用结束时变量的值。其值在整个程序运行期间都不释放。 寄存器变量(register) 对频繁使用的变量，为减少存取变量花费的时间，c语言允许将局部变量的值存放在CPU运算器的寄存器中，称为“寄存器变量”，用关键字“register”说明。 定义形式： 说明： 寄存器变量的类型一般只限于整型、字符型或指向整型、字符型的指针，且只用于局部变量和形参变量。 全局变量、局部静态变量不可以作为寄存器变量。 不能定义任意多个寄存器变量，因为一个计算机系统中寄存器的数目是有限的。不能取寄存器变量的地址。 不能使用取地址运算符“&amp;”求寄存器变量的地址。 全局变量的存储方式 外部全局变量 一个文件中要引用其他文件中定义的全局变量，应该在需要引用此变量的文件中用extern进行说明。 定义方式： 静态全局变量 一个文件中的全局变量仅限于定义它的文件引用，而不能被其它文件访问,熏要用static进行说明。 定义方式： 说明： 外部全局变量与静态全局变量在同一文件内的作用域一样； 外部全局变量可以被多个文件引用，而静态全局变量仅在定义它的文件内有效，在程序的其它文件中不可使用。 内部函数和外部函数 内部函数 内部函数是只能被本文件中其他函数调用的函数，又称静态函数，函数的作用域仅限于本文件。 定义形式： 作用： 使用内部函数，可以使函数只局限于所在文件，如果在不同的文件中有同名的内部函数，互不干扰。 这样不同的人可以分别编写不同的函数，而不必担心所用函数是否会与其他文件中函数同名。 外部函数 外部函数是允许被其它文件调用的函数。 定义形式： 说明： 在需要调用此函数的文件中，要用extern声明所用函数是外部函数。 例如，在源文件A中调用另一源文件B中的函数fun，则需要在源文件A中对函数fun进行说明，格式为: extern int fun() ; 编译预处理C语言源文件要经过编译、链接才能生成可执行程序： 编译（Compile）会将源文件（.c文件）转换为目标文件。对于 VC/VS，目标文件后缀为.obj；对于GCC，目标文件后缀为.o。 编译是针对单个源文件的，一次编译操作只能编译一个源文件，如果程序中有多个源文件，就需要多次编译操作。 接（Link）是针对多个文件的，它会将编译生成的多个目标文件以及系统中的库、组件等合并成一个可执行程序。 预处理是在编译之前对程序中的特殊命令进行的处理工作，由预处理程序完成。以#开头的是C语言的编译预处理命令。 当对一个源文件进行编译时，系统将自动调用预处理程序对源程序中的预处理部分作处理，处理完毕自动进入对源程序的编译。 C语言中的预处理命令分类: 宏定义#define 文件包含#include 条件编译#if( ) 宏定义 功能：在预处理时，将程序中宏定义之后出现的所有的宏名,用宏替换字符串代替。这个过程也称为宏展开，即将宏名替换成字符串的过程。 一般形式： 说明： 宏定义通常放在程序开头，以#开头，不加分号。 宏名一般习惯用大写字母表示。 一个宏名只能被定义一次。 宏定义的作用域：从定义开始到程序结尾。 在进行宏定义时，可以引用已定义的其他宏名。 对在字符串常量及用户标识符中，与宏名相同部分不作替换。 优点： 可提高源程序的可维护性; 可提高源程序的可移植性; 减少源程序中重复书写字符串的工作量。 带参数的宏定义 功能：预处理程序对程序中所有带实参表的宏名进行宏展开替换。 一般形式： 有参宏的调用和宏展开 调用格式：宏名(实参表) 例如： 宏展开：首先进行宏展开，然后用宏调用提供的实参字符串，直接置换宏定义命令行中相应形参字符串，非形参字符保持不变。 例如： 文件包含 文件包含是指一个源文件可以将另一个源文件的全部文本内容插入到它所在的位置。 两种形式： 说明： 只包含源文件，不包含可执行文件和目标文件。 一个#include只能包含一个文件。 可以将常用的符号常量、带参数的宏定义、外部变量及构造类型的变量等定义在一个独立的文件中，为其他文件共享。 条件编译 预处理程序提供了条件编译的功能,可以按不同的条件去编译不同的程序部分,因而产生不同 的目标代码文件,这对于程序的移植和调试是很有用的。 三种形式： 第一种 它的功能是如果标识符已被 #define 命令定义过则对程序段 1 进行编译；否则对程序段 2 进行编译。如果没有程序段2(为空),本格式中的#else 可以没有，即可以写为: 第二种 与第一种形式的区别是将“ifdef”改为“ifndef”。它的功能是如果标识符未被#define 命令定义过则对程序段 1 进行编译,否则对程序段 2 进行编译。这与第一种形式的功能正好相反。 第三种 它的功能是如果常量表达式的值为真(非 0)，则对程序段 1 进行编译，否则对程序段 2 进行编译。 条件编译的作用： 可有效地提高程序的可移植性，并广泛地应用在商业软件中，为一个程序提供各种不同的版本。 其他预处理指令 #error #error 指令强制编译程序停止编译,它主要用于程序调试 一般形式： 注意,宏串 error-message 不用双引号引起来。遇到#error 指令时,错误信息被显示,可能同时还显示编译程序作者预先定义的其他内容。 #line #line 指令改变__LINE__和__FILE__的内容。__LINE__和__FILE__都是编译程序中预定义的标识符。__LINE__的内容是当前被编译代码行的行号；__FILE__的内容是当前被编译源文件的文件名。 一般形式： 其中,number 是正整数并变成__LINE__的新值; 可选的“filename”是合法文件标识符并变成__FILE__的新值。#line 主要用于调试和特殊应用。 #pragma #pragma 是编译程序实现时定义的指令，它允许由此向编译程序传入各种指令。 例如，一个编译程序可能具有支持跟踪程序执行的选项，此时可以用#pragma 语句选择该功能，编译程序忽略其不支持的#pragma 选项。 使用#pragma 预处理命令可提高 C 源程序对编译程序的可移植性。 "},{"title":"C语言程序设计基础06-函数","date":"2021-12-10T17:38:28.000Z","url":"/2021/12/11/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%8006-%E5%87%BD%E6%95%B0/","tags":[["C编程","/tags/C%E7%BC%96%E7%A8%8B/"],["C/C++","/tags/C-C/"]],"categories":[["C/C++编程","/categories/C-C-%E7%BC%96%E7%A8%8B/"]],"content":"函数就是一段封装好的，可以重复使用的代码，它使得我们的程序更加模块化，不需要编写大量重复的代码。 模块化程序设计思想模块化程序设计方法： 在处理某个复杂问题时，通常采用逐步分解、分而治之的方法，即将一个复杂的大问题，分解为若干个独立简单的小问题（即模块），分别解决简单的小问题，进而解决复杂的大问题。 模块化程序设计优点: 模块相对独立，功能单一； 减少重复编写程序的工作量； 使程序便于调试和阅读； 利于团队开发，缩短开发周期。 函数的定义及调用什么是函数 函数是构成C语言程序的基本模块 函数是按规定格式书写的能完成特定功能的一段程序； 函数可以根据需要与调用函数之间进行数据传递； 函数之间地位平等，可以互相调用也可以自身调用； 函数的分类 标准库函数（由系统提供） 库（Library）是编程中的一个基本概念，可以简单地认为它是一系列函数的集合，在磁盘上往往是一个文件夹。C语言自带的库称为标准库（Standard Library），其他公司或个人开发的库称为第三方库（Third-Party Library）。 自定义函数 用户自己编写的函数 函数定义一般形式： 说明： 函数名代表函数的入口地址，最好能反映其代表的功能。 函数参数用来传递数据，必须分别定义； 如果有返回值，在函数体中使用 return 语句返回。return出来的数据的类型要和函数定义的返回值类型 一样。 函数调用 函数语句调用 一般形式： 通过函数调用语句调用函数，用于调用没有返回值的函数。 函数表达式调用方式 一般形式： 函数有返回值，函数调用出现在一个赋值表达式中，要求函数带回一个确定的值参加表达式的运算。 函数原型声明函数必须先定义后使用，就像变量先定义后使用一样。 当自定义函数被放在了主调函数的后面，就需要在函数调用之前，加上函数的原型声明。 C编译器自上而下顺序分析程序代码；当遇到函数调用时，需要知道函数的相关信息。 格式： 函数原型声明的作用： 通知编译器函数的返回值类型、函数希望接受的参数个数、类型和顺序，为编译器检查函数调用语句是否合理提供依据。 当被调函数定义在函数之前时，不需要函数声明。 函数的参数传递形式参数：函数定义时的参数，简称形参。 实际参数：函数调用时的参数，简称实参。 实参与形参数目、类型和顺序应一致，占据不同存储单元。 函数调用的执行过程 对实参进行求值（按从右向左的顺序进行)； 保护函数调用断点现场，将程序流程转向函数入口地址； 为函数内的形参和局部变量分配内存单元； 把实参值复制一份传递给形参（单向传值） 执行函数内的语句序列； 当执行到return语句或遇到函数结束的&quot;&#125;&quot;，从函数退出，返回到调用函数的地址； 把函数值带回给主调函数，收回分配给函数内形参和变量的存储单元。 单向值传递： 每个函数都有自己的变量空间，参数也位于这个空间； 形参调用前不占内存单元，调用时对形参分配存储单元并传递实参的值; 调用结束后，形参单元被释放，实参单元仍保留并维持原值； 形参值的变化不会改变主调函数中实参的值。 数组做函数参数 由于数组名代表数组在内存中存放区域的首地址，使用数组名作为函数参数，可以实现批量数据的共享,以及数据的同步更新。 运行时编译器不在为形参数组分配存储空间，实参与形参数组共用一组存储单元。调用时只需复制实参数组的基地址值给形参数组，而无须复制全部需要处理的数据，节约存储空间，提高效率。 一维数组做函数参数 实参、形参分别定义数组，名字可以相同，也可以不同； 调用时参数实现地址传递； 函数调用时实参用不带下标的数组名，必须有确切值； 形参数组和实参数组长度可以不相同，在调用时，只传送首地址而不检查形参数组的长度； 一维数组可以不指定大小； 对形参数组的修改即是对实参数组的修改，函数无须返回数组。 实例： 计算n元一维数组的平均值。 二维数组做参数 函数定义中，形参数组的定义可以省略第一维的大小，但是不能省略第二维的大小，因为必须知道列数才能正确计算一个数组元素在数组中相对于第一个元素的偏移位置。 函数调用时，向函数传递二维数组的首地址。 函数的嵌套调用和递归调用嵌套调用 嵌套调用：在调用一个函数的过程中，又调用另一个函数。 函数不能嵌套定义，但可以嵌套调用。 一般形式： 递归调用 递归调用：在调用一个函数的过程中又出现直接或间接地调用该函数本身，前者称为直接递归，后者称为间接递归。 直接递归： 间接递归： 递归的优缺点： 优点：程序简洁，代码紧凑。 缺点：每调用函数一次，在内存堆栈区分配空间，用于存放函数变量、返回值等信息。所以递归次数过多，可能引起堆栈溢出，且时间效率较差。 注意： 递归一般有两个步骤：递推和回归 递归一定要有终止条件 实例： 使用递归计算n! "},{"title":"C语言程序设计基础05-数组","date":"2021-12-09T22:36:20.000Z","url":"/2021/12/10/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%8005-%E6%95%B0%E7%BB%84/","tags":[["C编程","/tags/C%E7%BC%96%E7%A8%8B/"],["C/C++","/tags/C-C/"]],"categories":[["C/C++编程","/categories/C-C-%E7%BC%96%E7%A8%8B/"]],"content":"C 语言支持数组数据结构，它可以存储一个固定大小的相同类型元素的顺序集合。数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量。 一维数组 定义：类型说明符 数组名 [常量表达式]; 说明： 类型说明符:数组的类型。 数组名同变量名命名规则相同。 常量表达式指明数组中元素个数，必须大于零，可以是数值常量、符号常量和字符常量。 数组是一个整体，它在内存是一片连续的区域。 一维数组初始化在数组定义时为数组元素赋初值称为数组初始化。 对全部元素初始化 方法：将初值依次写在花括号{}内。 给数组部分赋初值，其他为0 对数组元素全部赋值，可以不指定长度 一维数组的引用 引用形式：数组名[下标] 说明： 下标可以是整型常量、整型变量或整型表达式。 下标的值是数组元素的序号，从0到n-1。 数组中的每个元素在功能上等价于一个一般的变量。 注意： 数组名是数组的首地址,也就是array[0]的地址，是一个地址常量，数组元素则是数值 引用数组元素时，根据首地址和下标，自动计算出该元素的实际地址，取出该地址的内容进行操作。 数组名是第一个元素的地址，不同数组名之间不能赋值。 二维数组 定义：类型说明符 数组名 [常量表达式1][常量表达式]； 二维数组在内存中按行的顺序存放，即先存放第一行的元素，再存放第二行的元素。 二维数组的初始化 分行给二维数组赋初值 将所有数据写在一个{}内，按顺序赋值。即按数组元素在内存中排列的顺序赋初值。 对部分元素赋初值 二维数组的引用与一维数组类似，采用下标引用。 形式：数组名[下标1][下标2] 说明：数组名array的地址是数组的首地址，也就是array[0][0]的地址 字符数组 定义：用来存放字符的数组称为字符数组。字符数组的各个元素依次存放字符串的各字符。 格式：char 数组名[常量表达式]; 若字符数组具有n个元素，则可以存储小于等于n-1个字符 因为字符数组的末尾要存储字符串结束符&#39;\\0&#39;； &#39;\\0&#39;是 ASCII 码表中的第 0 个字符，英文称为 NULL，中文称为“空字符”。该字符既不能显示，也没有控制功能，输出该字符不会有任何效果，它在C语言中唯一的作用就是作为字符串结束标志。 字符数组的初始化 用单个字符对数组初始化 注意： 初值的个数不能超过数组元素的个数，否则语法错误 初值的个数小于数组长度，系统自动添入结束符&#39;\\0&#39; 初值的个数与数组元素相等，定义时可省略长度 用字符串对数组初始化 注意： 将字符串存储到字符数组中，字符串和第一个’\\0’构成有效字符串。对字符串的操作，就是对字符数组的操作。 普通数组中的元素是确定的，一般用下标控制循环；而字符串使用结束符’\\0’来控制循环。 字符串处理函数C函数库中提供一些用来处理字符串的函数： 字符数组的输入输出 单字符的输入输出 使用格式符%c或者字符输入函数 字符串的输入输出 使用格式符%s C语言在处理字符串时，会从前往后逐个扫描字符，一旦遇到&#39;\\0&#39;就认为到达了字符串的末尾，就结束处理。 "},{"title":"C语言程序设计基础04-选择结构和循环结构","date":"2021-12-09T15:31:38.000Z","url":"/2021/12/09/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%8004-%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84%E5%92%8C%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/","tags":[["C编程","/tags/C%E7%BC%96%E7%A8%8B/"],["C/C++","/tags/C-C/"]],"categories":[["C/C++编程","/categories/C-C-%E7%BC%96%E7%A8%8B/"]],"content":"C语言中有三大结构，分别是顺序结构、选择结构和循环结构 选择结构 选择结构：根据给定的判断条件，控制程序执行流程的语句。 if-else语句单分支if语句： 双分支if-else语句： 多分支if-else语句 switch语句switch语句的执行过程为：首先计算表达式的值，然后依次与常量表达式依次进行比较，若表达式的值与某常量表达式相等，则从该常量表达式处开始执行，直到switch语句结束。若所有的常量表达式的值均不等于表达式的值，则从default处开始执行。 如果希望只执行某一个分支，而跳过后面的其他分支，必须要在每个分支最后添加break;语句。 任何一种选择结构都可以用if语句来实现，但并非所有的if语句都有等价的switch语句。switch语句只能用来实现以相等关系作为选择条件的选择结构。 条件运算符条件运算符：唯一的三目运算符，要求有三个操作对象。 首先计算表达式1的值，判断表达式1的真假。如果表达式1为真，三目运算符整体的值就是表达式2的值，否则（表达式1不成立），这个三目运算符整体的值就是表达式3的值。 循环结构while语句 先计算“表达式”的值，当值为真（非0）时， 执行“语句块”；执行完“语句块”，再次计算表达式的值，如果为真，继续执行“语句块”……这个过程会一直重复，直到表达式的值为假（0），就退出循环，执行 while 后面的代码。 我们通常将“表达式”称为循环条件，把“语句块”称为循环体，整个循环的过程就是不停判断循环条件、并执行循环体代码的过程。 do-while语句 do-while循环与while循环的不同在于：它会先执行“语句块”，然后再判断表达式是否为真，如果为真则继续循环；如果为假，则终止循环。因此，do-while 循环至少要执行一次“语句块”。 for循环语句 for语句的三个表达式均可省略，for(;;;)，但分号不能省略。 循环嵌套 定义：在循环体内又包含一个循环语句，称为循环嵌套。 打印九九乘法表： 运行结果： 内层 for 每循环一次输出一个数据，而外层 for 每循环一次输出一行数据。 循环流程控制break语句 功能：终止包含该语句的最内层循环。 continue语句 功能：结束循环体的本次执行，进入下一次执行 break与continue的对比：break 用来结束所有循环，循环语句不再有执行的机会；continue 用来结束本次循环，直接跳到下一次循环，如果循环条件成立，还会继续循环。 goto语句 功能：程序无条件跳到标号指定的位置继续执行。 不推荐使用 迭代法关键步骤： 确定迭代变量：也就是直接或间接地不断由旧值递推出新值的变量。 建立迭代关系式：指如何从变量的前一个值推出其下一个值的公式(或关系)。 对迭代过程进行控制。在什么时候结束迭代过程? 一般形式： 经典算法例题： 斐波那契数列 求最大公约数 "},{"title":"C语言程序设计基础03-数据的输入输出","date":"2021-12-08T14:07:59.000Z","url":"/2021/12/08/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%8003-%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/","tags":[["C编程","/tags/C%E7%BC%96%E7%A8%8B/"],["C/C++","/tags/C-C/"]],"categories":[["C/C++编程","/categories/C-C-%E7%BC%96%E7%A8%8B/"]],"content":"输入输出（Input and Output, IO）是用户和程序“交流”的过程。在控制台程序中，输出一般是指将数据（包括数字、字符等）显示在屏幕上，输入一般是指获取用户在键盘上输入的数据。 数据的格式化输出 输出：从计算机向显示器、打印机等外部设备输出数据。 输入：从标准输入设备键盘、鼠标等向计算机输入数据。 格式输出函数printf 格式：printf(“格式控制字符串”,输出表项); 常用的格式控制符： 字符 含义 d , i 以十进制形式输出有符号整数(正数不输出符号) o 以八进制形式输出无符号整数(不输出前缀0) x 以十六进制形式输出无符号整数(不输出前缀0x) u 以十进制形式输出无符号整数 f 以小数形式输出单、双精度类型实数 e 以指数形式输出单、双精度实数 g 以%f或%e中较短输出宽度的一种格式输出单、双精度实数 c 输出单个字符 s 输出字符串 printf()的格式修饰符： 字符 含义 - 当数据的宽度小于显示宽度时，数据左对齐，右方补空格 m 输出数据占m个字符位，若实际数据的宽度大于m，按实际输出;实际数据的宽度小于m ，数据右对齐，左边填空格 n 输出数据有n位小数 m.n 输出数据占m列，n位小数 l 用于常整型或双精度型数据 % %%用于输出字符% printf()的返回值： printf函数的返回值是返回所打印的字符的数目。 数据的交互式输入输入函数scanf 格式：scanf(“格式控制字符串”，输入项地址列表); //“格式控制字符串“用来指出输入的格式，由“%”和格式符以及普通字符组成。//”地址列表“由若干个地址组成，可以是变量地址或者字符串首地址 格式控制符： scanf()函数所用的格式控制符与printf()所用的几乎完全相同。主要区别在于printf()把%f、%e、%E、%g、%G同时用于float类型和double类型，而scanf()只是把他们用于float类型，而用于double类型时要求使用l(字母l)修饰符。 符号 含义 %c 把输入解释成一个字符 %d 把输入解释成一个有符号十进制整数 %e,%f,%g,%a 把输入解释成一个浮点数(%a是C99的标准) %E,%F,%G,%A 把输入解释成一个浮点数(%A是C99的标准) %i 把输入解释成一个有符号十进制整数 %o 把输入解释成一个有符号的八进制整数 %p 把输入解释成一个指针(一个地址) %s 把输入解释成一个字符串：输入的内容以第一个非空白字符作为开始，并且包含直到下一个空白字符的全部字符 %u 把输入解释成一个无符号十进制整数 %x,%X 把输入解释称一个有符号十六进制整数 格式修饰符： 符号 含义 m 指定输入数据的位宽 l 加在d、u格式前表示输入long型数据加在f、e格式前表示输入double型数据 L 加在f、e格式前表示输入long double型数据 h 加在d格式前表示输入short型数据 scanf()的返回值： scanf() 函数返回成功读入的项目的个数。如果它没有读取任何项目(比如它期望接收一个数字而您却输入的一个非数字字符时就会发生这种情况),scanf()返回0。 在scanf函数的格式控制字符串中尽量不要写入普通字符提示信息。 注意： 采用正确的格式输入数据,是程序运行正确的基础。 输入时不允许指定数据的精度。 输入时不允许加“\\n”。 不能使用中文的标点符号。 字符输入输出字符输入函数getchar 功能：接收用户从键盘上输入的一个字符 getchar会以返回值的形式返回接收到的字符 使用多次getchar()注意：输入的数据放在输入行缓冲区，直到键入回车符或文件结束符EOF 时，才认为输入结束，getchar())才开始从输入缓冲队列读取字符。前面函数没读走的数据仍在缓冲队列中，将被下一个函数读取。 解决：输入间插入一个getchar() 字符输出函数putchar 功能：在终端输出单个字符 "},{"title":"C语言程序设计基础02-变量及表达式","date":"2021-12-07T16:07:14.000Z","url":"/2021/12/08/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%8002-%E5%8F%98%E9%87%8F%E5%8F%8A%E8%A1%A8%E8%BE%BE%E5%BC%8F/","tags":[["C编程","/tags/C%E7%BC%96%E7%A8%8B/"],["C/C++","/tags/C-C/"]],"categories":[["C/C++编程","/categories/C-C-%E7%BC%96%E7%A8%8B/"]],"content":"在计算机中，数据的性质和表示方式可能不同。所以需要将相同性质的数据归类，并用一定数据类型描述。任何数据对用户都呈现常量和变量两种形式。常量是指程序在运行时其值不能改变的量。常量不占内存，在程序运行时它作为操作对象直接出现在运算器的各种寄存器中。变量是指在程序运行时其值可以改变的量。变量的功能就是存储数据。 变量和常量变量定义 变量名：代表内存中的存储单元；变量通过变量名标识，变量名和内存中的存储单元相对应，通过变量名来存、取存储单元的内容。 变量地址：系统分配给变量的存储单元的起始地址。 变量类型：定义时指定，决定存储单元的大小和数据的存储方式。 变量的值：对应变量名存储单元存放的具体数值。 数据类型算数类型分类 数据类型 说明 所占字节 表示范围 short (short int) 短整型 2字节 -2^15~2^15-1 int 整型 4字节 -2^31~2^31-1 long (long int) 长整型 4字节 -2^31~2^31-1 unsigned short 无符号短整型 2字节 02^16-1 (即065535) unsigned int 无符号整形 4字节 0~2^32-1 unsigned long 无符号长整形 4字节 0~2^32-1 char 字符型 1字节 -128-127 float 单精度实型 4字节 -3.4×10^38~3.4×10^38 double 双精度实型 8字节 -1.7×10^308~1.7×10^308 long double 长双精度 8字节 -1.7×10^308~1.7×10^308 sizeof运算符 功能：获取变量和数据类型所占内存大小（字节数) 格式：sizeof 表达式 ​ sizeof (数据类型或者表达式) 存储方式整数 整数采用有符号和无符号方式按指定位进行存储 浮点数 浮点数可以扩大实数的表示范围，表示既有整数部分、又有小数部分的实数；采用尾数和阶码方式存储 浮点数表示的数仅是数值的近似值，并非真正意义的实数 常量表示方法 十进制：0~9 八进制：0~7，以0开头 十六进制：0~F，以0x或者0X开头 实型常量分为： 十进制数形式：由数字、小数点、正负号组成。（必须要有小数点） 指数形式：由数字、小数点、字母e或E及正负号组成。(e或E之前必须有数字，且后指数必须为整数) 实型常量后面加f (或F) 表示单精度类型，加l (或L) 表示双精度类型，默认双精度。 符号常量 符号常量：用一个符号代表一个常量，必须在函数开始用宏定义声明后使用。 定义格式：#define 宏名 字符串 功能：在程序编译时，首先使用符号串替换程序中的所有宏名，再进行编译。符号串可以是常量、表达式、 格式串等。 例如 const常量 定义格式：const 数据类型 变量名=数值; 功能：声明某个常量字段或常量局部变量。 常量字段和常量局部变量不是变量并且不能修改。 字符常量字符型数据用来表示一个字符值。在计算机内部存储字符的ASCII码值。 区分 字符常量：用单引号括起来的一个字符。如 ‘a’, ‘1’ 字符串常量：用双引号括起来一个或多个字符。如”abc123”,”a”,”\\n” 转义字符 运算符和表达式 运算符：描述各种操作的符号 表达式：由运算符连接的式子 算术运算符 单目运算符 对于前缀运算符，先执行自增或自减运算，再计算表达式的值，而后缀运算符，则先计算表达式的值，再执行自增或自减运算。 双目运算符 三目运算符 首先计算表达式1的值，判断表达式1的真假。如果表达式1为真，三目运算符整体的值就是表达式2的值，否则（表达式1不成立），这个三目运算符整体的值就是表达式3的值。 关系运算符 关系运算符 含 义 数学中的表示 &lt; 小于 &lt; &lt;= 小于或等于 ≤ &gt; 大于 &gt; &gt;= 大于或等于 ≥ == 等于 = != 不等于 ≠ 运算结果 1 称为“真”，表示条件成立，将 0 称为“假”，表示条件不成立。 逻辑运算符 名称 作用 逻辑与 &amp;&amp; 将两个表达式连接成一个。两个表达式必须都为 true，整个表达式才为 true 逻辑或 || 将两个表达式连接成一个。必须有一个或两个表达式为 true，才能使整个表达式为 true。只要其中有一个为 true，那么另外一个就变得无关紧要 逻辑非 ！ 使一个表达式从 true 变成了 false，或者从 false 变成了 true 优先级： 位运算符 名称 作用 左移运算符 &lt;&lt; 向左（即高位）移位，右侧补0 右移运算符 &gt;&gt; 向右（即低位）移位，左侧补0 按位取反 ~ 如名，即0变1，1变0 按位与 &amp; 相对应的两个位都为1则为1，反之为0 按位或 | 相对应的两个位至少有一个为1即为1，反之为0 按位异或 ^ 相对应的两个位相同为0，相异（不同）为1 赋值运算符赋值运算符：= 形式：变量名=常量 功能：将右边常量或表达式的值赋给左边的变量。 如果右边表达式的值的类型与左边变量的类型不一致，以左边变量的类型为准，将表达式值的类型转换为左边变量的类型。 复合赋值运算符： 算术运算符相关 位运算相关 运算符的优先级： **赋值运算符(=) &lt; &amp;&amp;和|| &lt; 关系运算符 &lt; 算术运算符 &lt; 非(!)**&amp;&amp; 和 || 低于关系运算符，! 高于算术运算符。 数据类型转换 隐式转换（自动转换） 整型、实型和字符型可以混合运算，系统自动转换成占内存字节数最大的操作数类型。 一般类型转换为标准类型 float型转换成double型； char和short int型转换成int型。 不同类型转换为相同类型，转换规则“由低到高 显示转换（强制转换） 强制类型转换：将表达式的值转换为指定类型。 形式：(类型名)表达式 可以自动转换的类型一定能够强制转换，但是，需要强制转换的类型不一定能够自动转换。"},{"title":"Markdown书写帮助","date":"2021-12-07T08:45:18.000Z","url":"/2021/12/07/Markdown%E4%B9%A6%E5%86%99%E5%B8%AE%E5%8A%A9/","tags":[["帮助文档","/tags/%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3/"],["Markdown","/tags/Markdown/"],["Hexo","/tags/Hexo/"]],"categories":[["帮助文档","/categories/%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3/"]],"content":"对markdown书写的记录 引用块 代码块 Extra Options Description Default line_number Show line number true highlight Enable code highlighting true first_line Specify the first line number 1 mark Line highlight specific line(s), each value separated by a comma. Specify number range using a dash Example: mark:1,4-7,10will mark line 1, 4 to 7 and 10. wrap Wrap the code block in table true 参考hexo文档 引用文章 引用资源 引用Note 其中 [ type ] 可选填：info、important、tip、caution、warning，分别对应 5 种样式。 注意好好学习 注意好好学习 注意好好学习 注意好好学习 注意好好学习 文章摘要文章默认摘要，可以（且推荐）使用 &lt;!--more--&gt; 标记精确截取文章部分作为摘要。 创建文章 write-matter Markdown颜色字体第一种（不推荐） 第二种 颜色brown peru chocolate sienna firebirck darkred #C7254E mediunmvioletred red orangered tomato orange goldenrod gold yellowgreen lawngreen lime limegreen lightseagreen seagreen green lightskyblue deepskyblue dodgerblue LightSlateBlue blue deeppink hotpink violet MediumOrchid fuchsia magenta violetred darkorchid darkviolet purple"},{"title":"C语言程序设计基础01-程序设计与C语言简介","date":"2021-12-06T17:27:15.000Z","url":"/2021/12/07/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%8001-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8EC%E8%AF%AD%E8%A8%80%E7%AE%80%E4%BB%8B/","tags":[["C编程","/tags/C%E7%BC%96%E7%A8%8B/"],["C/C++","/tags/C-C/"]],"categories":[["C/C++编程","/categories/C-C-%E7%BC%96%E7%A8%8B/"]],"content":"C语言是一门面向过程的编译型语言，它的运行速度极快，仅次于汇编语言。C语言是计算机产业的核心语言，操作系统、硬件驱动、关键组件、数据库等都离不开C语言。 MOOC学习视频 一、程序设计与C语言简介算法的基础算法的概念 算法(Algorithm)是为解决一个特定问题而采取的方法和步骤。利用计算机解决问题，就需要告诉计算机如何去计算的步骤。计算机做的所有事情都叫做计算。 算法的特征 有穷性：算法必须在执行有限个操作后终止; 确定性：算法中每一步的含义必须是确切的，不能出现任何二义性; 有效性：法中的每一步操作都应该能有效执行，一个不可执行的操作是无效的; 有零个或多个输入：执行算法时，从外界获得必要信息; 有一个或多个输出：算法的解就是输出。 算法描述方法 自然语言 流程图 N-S图 伪代码 算法的性能评价时间复杂度：为便于比较解决同一问题的不同算法，通常以算法中基本操作重复执行的频度作为算法的时间度量标准。 空间复杂度：算法的空间复杂度是指算法执行时存储空间需求的度量。 初试C程序编译器选择 Visual C++ 6.0 Dev C++ Visual Studio Visual Studio Code 第一个C程序 比较两个数的大小"},{"title":"基于vscode的C/C++配置","date":"2021-12-06T16:56:20.000Z","url":"/2021/12/07/%E5%9F%BA%E4%BA%8Evscode%E7%9A%84%E9%85%8D%E7%BD%AE/","tags":[["C/C++","/tags/C-C/"],["VSCode","/tags/VSCode/"],["MinGW","/tags/MinGW/"],["编译器","/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"],["环境搭建","/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"]],"categories":[["软件安装配置","/categories/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"]],"content":"VSCode（Visual Studio Code）是一款由微软开发且跨平台的免费源代码编辑器。VSCode相对于VS集成开发环境更加小巧方便，不仅持有基础的编辑器功能，还能进行远程开发和调试。本文基于vscode实现对C/C++语言编译环境的安装和配置。 安装vscodevscode下载地址 默认安装即可 vscode下有全局设置settings.json;之后是工作区,和工作区设置settings.json,一个工作区包含了多个文件夹;每个文件夹中有相同的.vscode文件夹,这个文件夹中的三个文件settings.json,tasks.json,launch.json,它们就是配置的核心。每个文件夹通过配置可以编译运行不同语言的文件:c++,python和html,同时可以通过同一个工作区直接访问,这就是vscode的集成性和方便性。 C/C++配置建议参考官方配置文档 安装MinGW 本人只给出了方法，但MinGW安装很慢，我直接放弃了，所以之后直接使用了VS的MSVC编译器。 C/C++的编译环境MinGW: 然后将bin文件下的路径添加到环境变量 安装C/C++扩展 创建文件夹作为工作区 点击【文件】-【打开文件夹】，选择一个文件夹作为工作区，然后点击【文件】-【将工作区另存为】，设置工作空间的名字 这样我们可以将当前的文件夹作为C/C++编译的工作环境 创建一个文件 配置C/C++环境配置编译器 按Ctrl + Shift + P打开命令调面板，并输入C/C++，并点击编辑配置”（UI） 这里，系统默认识别了Microsoft C ++编译器的路径（cl.exe），因为我安装了visial studio，那我就默认使用了。 可以看到程序文件夹多了一个.vscode文件夹，出现了新的文件：c_cpp_properties.json，这个自动生成的文件不需要修改 此时可以对程序编译运行了 配置构建任务首先按Ctrl + Shift + P打开命令调面板，输入：tasks选择Tasks:Configure Default Build Task 在弹出的界面 再点 c/c++：cl.exe如图： 此时会出现一个名为tasks.json的配置文件。 配置调试设置这里主要是为了在.vscode文件夹中产生一个launch.json文件，用来配置调试的相关信息。 点击【调试】【C / C++Windows】再选择【cl.exe】 查看launch.json代码吗，stopAtEntry值设置为true使调试器在该断点上停止。最好为true vscode插件vscode有很多好用的插件 Code Runner【setting】中搜索code runner，找到【Run In Terminal】勾选 出现这样的报错需要更改PowerShell 的执行策略，Windows的默认执行策略是restricted 解决方案： 以管理员身份运行PowerShell 输入set-ExecutionPolicy RemoteSigned get-ExecutionPolicy可以查看当前的策略 参考官方文档：PowerShell 执行策略 卸载vscode编译器没有好坏，只有合不合适自己，从而提高开发效率 完全卸载步骤： 卸载应用程序 删除保存所有的插件C:\\Users\\yknut\\.vscode 删除个人配置和缓存文件C:\\Users\\yknut\\AppData\\Roaming\\Code "},{"title":"利用Burpsuite爆破路由器管理员密码","date":"2020-04-12T16:00:00.000Z","url":"/2020/04/13/brute_router_passwd/","tags":[["网络安全","/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"],["burpsuite","/tags/burpsuite/"],["路由器","/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/"]],"categories":[["网络安全","/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"]],"content":"前言之前家里网断了，找人来修，于是就升级了一下网络，并重新换了猫和路由器,但管理员密码我并不知道，但初始应该是弱口令，我想可以用字典爆破一下。 工具burpsuite、Chrome 操作过程 使用burpsuit的Proxy对路由器登录进行抓包(密码随便输就行了） 很明显，密码在前端经过了加密，那我们不得不去查看前端加密的代码 每个厂家的路由器对密码加密方式都不一样，有的没有，我家的是tp-link,我猜这个厂家所有路由器管理员密码应该都是这样加密的8.这是关键代码： 明文字典是无法爆破的，所以我们可以将字典使用上面的代码进行加密，然后再进行爆破。这是参考上面的javascript写的python 拿到密文字典之后，赶快放到burpsuite中爆破一下 参考明文字典，得到的密码是123456，然后就可以成功登陆啦！总结我们平时一定要有防备意识，尽量修改一下路由器管理员的初始密码，有想法的人一旦进入到你家的内网，后果很严重的。其实字典爆破只能针对某些安全机制较低的路由器，大多路由器会限制你的登录次数，会认为是恶意登录，输满次数会让你重启路由器。所以运气不好，可能密码再简单，字典也没有用了，哈哈哈~ "},{"title":"友链","date":"2021-11-29T18:09:18.000Z","url":"/links/index.html","categories":[[" ",""]]},{"title":"关于我","date":"2021-11-29T20:57:40.000Z","url":"/about/index.html","categories":[[" ",""]],"content":" 宗旨贴士好好学习，天天向上 贴士好好学习，天天向上 贴士好好学习，天天向上 贴士好好学习，天天向上 "},{"title":"categories","date":"2021-11-29T16:05:51.000Z","url":"/categories/index.html","categories":[[" ",""]]},{"title":"请搜索","date":"2021-11-29T18:20:11.000Z","url":"/search/index.html","categories":[[" ",""]]},{"title":"标签","date":"2021-11-29T16:03:39.000Z","url":"/tags/index.html","categories":[[" ",""]]},{"title":"page","date":"2021-11-29T21:18:41.000Z","url":"/page/index.html","categories":[[" ",""]]}]